// Unit tests for Video Service
// Tests video CRUD operations and public token generation

import { mockConfig, createMockUser } from '../test/mocks';
import type { Video, VideoStatus } from '@prisma/client';

// Mock the config module
jest.mock('../config', () => ({
  getConfig: jest.fn(() => mockConfig),
}));

// Mock the logger
jest.mock('../logger', () => ({
  createChildLogger: jest.fn(() => ({
    debug: jest.fn(),
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
  })),
}));

// Mock the database
const mockPrismaVideo = {
  create: jest.fn(),
  findUnique: jest.fn(),
  findMany: jest.fn(),
  count: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
};

const mockPrismaUser = {
  findUnique: jest.fn(),
  update: jest.fn(),
};

jest.mock('../db', () => ({
  prisma: {
    video: mockPrismaVideo,
    user: mockPrismaUser,
  },
}));

import {
  createVideo,
  findVideoById,
  findVideoByPublicToken,
  getVideosByUser,
  updateVideoTitle,
  deleteVideo,
  updateUserStorageUsage,
  checkUserStorageQuota,
  getUserDefaultTimerDays,
  CreateVideoData,
} from './video.service';

/**
 * Create a mock video for testing
 */
function createMockVideo(overrides: Partial<Video> = {}): Video {
  return {
    id: 'video-id-123',
    userId: 'user-id-123',
    title: 'Test Video',
    filePath: 'user-id-123/test-video.mp4',
    fileSizeBytes: BigInt(1048576), // 1MB
    mimeType: 'video/mp4',
    status: 'ACTIVE' as VideoStatus,
    distributeAt: new Date('2026-01-25T00:00:00Z'),
    distributedAt: null,
    expiresAt: null,
    publicToken: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    createdAt: new Date('2026-01-18T00:00:00Z'),
    updatedAt: new Date('2026-01-18T00:00:00Z'),
    ...overrides,
  };
}

describe('Video Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('createVideo', () => {
    it('should create a video with all required fields', async () => {
      const mockVideo = createMockVideo();
      mockPrismaVideo.create.mockResolvedValue(mockVideo);

      const videoData: CreateVideoData = {
        userId: 'user-id-123',
        title: 'Test Video',
        filePath: 'user-id-123/test-video.mp4',
        fileSizeBytes: BigInt(1048576),
        mimeType: 'video/mp4',
        distributeAt: new Date('2026-01-25T00:00:00Z'),
      };

      const result = await createVideo(videoData);

      expect(mockPrismaVideo.create).toHaveBeenCalledTimes(1);
      expect(mockPrismaVideo.create).toHaveBeenCalledWith({
        data: {
          userId: 'user-id-123',
          title: 'Test Video',
          filePath: 'user-id-123/test-video.mp4',
          fileSizeBytes: BigInt(1048576),
          mimeType: 'video/mp4',
          status: 'ACTIVE',
          distributeAt: expect.any(Date),
        },
      });
      expect(result).toEqual(mockVideo);
    });

    it('should return video with publicToken (auto-generated by Prisma)', async () => {
      const mockVideo = createMockVideo({
        publicToken: 'abc12345-6789-4def-ghij-klmnopqrstuv',
      });
      mockPrismaVideo.create.mockResolvedValue(mockVideo);

      const videoData: CreateVideoData = {
        userId: 'user-id-123',
        title: 'Test Video',
        filePath: 'user-id-123/test.mp4',
        fileSizeBytes: BigInt(1000),
        mimeType: 'video/mp4',
        distributeAt: new Date(),
      };

      const result = await createVideo(videoData);

      // publicToken should be present in the returned video
      expect(result.publicToken).toBe('abc12345-6789-4def-ghij-klmnopqrstuv');
    });

    it('should set status to ACTIVE for new videos', async () => {
      const mockVideo = createMockVideo({ status: 'ACTIVE' });
      mockPrismaVideo.create.mockResolvedValue(mockVideo);

      const videoData: CreateVideoData = {
        userId: 'user-id-123',
        title: 'Test Video',
        filePath: 'user-id-123/test.mp4',
        fileSizeBytes: BigInt(1000),
        mimeType: 'video/mp4',
        distributeAt: new Date(),
      };

      const result = await createVideo(videoData);

      expect(result.status).toBe('ACTIVE');
      const createCall = mockPrismaVideo.create.mock.calls[0][0];
      expect(createCall.data.status).toBe('ACTIVE');
    });
  });

  describe('findVideoById', () => {
    it('should find an existing video', async () => {
      const mockVideo = createMockVideo();
      mockPrismaVideo.findUnique.mockResolvedValue(mockVideo);

      const result = await findVideoById('video-id-123');

      expect(mockPrismaVideo.findUnique).toHaveBeenCalledWith({
        where: { id: 'video-id-123' },
      });
      expect(result).toEqual(mockVideo);
    });

    it('should return null for non-existent video', async () => {
      mockPrismaVideo.findUnique.mockResolvedValue(null);

      const result = await findVideoById('non-existent');

      expect(result).toBeNull();
    });
  });

  describe('findVideoByPublicToken', () => {
    it('should find video by public token', async () => {
      const mockVideo = createMockVideo({
        publicToken: 'unique-public-token-uuid',
      });
      mockPrismaVideo.findUnique.mockResolvedValue(mockVideo);

      const result = await findVideoByPublicToken('unique-public-token-uuid');

      expect(mockPrismaVideo.findUnique).toHaveBeenCalledWith({
        where: { publicToken: 'unique-public-token-uuid' },
      });
      expect(result).toEqual(mockVideo);
    });

    it('should return null for invalid public token', async () => {
      mockPrismaVideo.findUnique.mockResolvedValue(null);

      const result = await findVideoByPublicToken('invalid-token');

      expect(result).toBeNull();
    });

    it('should only match exact public token', async () => {
      mockPrismaVideo.findUnique.mockResolvedValue(null);

      await findVideoByPublicToken('partial-match');

      expect(mockPrismaVideo.findUnique).toHaveBeenCalledWith({
        where: { publicToken: 'partial-match' },
      });
    });
  });

  describe('getVideosByUser', () => {
    it('should return paginated videos for a user', async () => {
      const mockVideos = [createMockVideo(), createMockVideo({ id: 'video-2' })];
      mockPrismaVideo.findMany.mockResolvedValue(mockVideos);
      mockPrismaVideo.count.mockResolvedValue(2);

      const result = await getVideosByUser('user-id-123');

      expect(result.videos).toEqual(mockVideos);
      expect(result.total).toBe(2);
      expect(mockPrismaVideo.findMany).toHaveBeenCalledWith({
        where: { userId: 'user-id-123' },
        orderBy: { createdAt: 'desc' },
        take: 50,
        skip: 0,
      });
    });

    it('should apply status filter', async () => {
      mockPrismaVideo.findMany.mockResolvedValue([]);
      mockPrismaVideo.count.mockResolvedValue(0);

      await getVideosByUser('user-id-123', { status: 'DISTRIBUTED' });

      expect(mockPrismaVideo.findMany).toHaveBeenCalledWith({
        where: { userId: 'user-id-123', status: 'DISTRIBUTED' },
        orderBy: { createdAt: 'desc' },
        take: 50,
        skip: 0,
      });
    });

    it('should apply custom limit and offset', async () => {
      mockPrismaVideo.findMany.mockResolvedValue([]);
      mockPrismaVideo.count.mockResolvedValue(0);

      await getVideosByUser('user-id-123', { limit: 10, offset: 20 });

      expect(mockPrismaVideo.findMany).toHaveBeenCalledWith({
        where: { userId: 'user-id-123' },
        orderBy: { createdAt: 'desc' },
        take: 10,
        skip: 20,
      });
    });

    it('should return empty array when user has no videos', async () => {
      mockPrismaVideo.findMany.mockResolvedValue([]);
      mockPrismaVideo.count.mockResolvedValue(0);

      const result = await getVideosByUser('user-id-123');

      expect(result.videos).toEqual([]);
      expect(result.total).toBe(0);
    });
  });

  describe('updateVideoTitle', () => {
    it('should update video title', async () => {
      const updatedVideo = createMockVideo({ title: 'New Title' });
      mockPrismaVideo.update.mockResolvedValue(updatedVideo);

      const result = await updateVideoTitle('video-id-123', 'New Title');

      expect(mockPrismaVideo.update).toHaveBeenCalledWith({
        where: { id: 'video-id-123' },
        data: { title: 'New Title' },
      });
      expect(result?.title).toBe('New Title');
    });

    it('should return null for non-existent video', async () => {
      const error = { code: 'P2025' };
      mockPrismaVideo.update.mockRejectedValue(error);

      const result = await updateVideoTitle('non-existent', 'Title');

      expect(result).toBeNull();
    });

    it('should throw on other errors', async () => {
      const error = new Error('Database error');
      mockPrismaVideo.update.mockRejectedValue(error);

      await expect(updateVideoTitle('video-id', 'Title')).rejects.toThrow('Database error');
    });
  });

  describe('deleteVideo', () => {
    it('should delete existing video', async () => {
      const mockVideo = createMockVideo();
      mockPrismaVideo.delete.mockResolvedValue(mockVideo);

      const result = await deleteVideo('video-id-123');

      expect(mockPrismaVideo.delete).toHaveBeenCalledWith({
        where: { id: 'video-id-123' },
      });
      expect(result).toEqual(mockVideo);
    });

    it('should return null for non-existent video', async () => {
      const error = { code: 'P2025' };
      mockPrismaVideo.delete.mockRejectedValue(error);

      const result = await deleteVideo('non-existent');

      expect(result).toBeNull();
    });

    it('should throw on other errors', async () => {
      const error = new Error('Database error');
      mockPrismaVideo.delete.mockRejectedValue(error);

      await expect(deleteVideo('video-id')).rejects.toThrow('Database error');
    });
  });

  describe('updateUserStorageUsage', () => {
    it('should increment user storage usage', async () => {
      mockPrismaUser.update.mockResolvedValue(createMockUser());

      await updateUserStorageUsage('user-id-123', BigInt(1000));

      expect(mockPrismaUser.update).toHaveBeenCalledWith({
        where: { id: 'user-id-123' },
        data: {
          storageUsedBytes: {
            increment: BigInt(1000),
          },
        },
      });
    });

    it('should decrement user storage usage with negative value', async () => {
      mockPrismaUser.update.mockResolvedValue(createMockUser());

      await updateUserStorageUsage('user-id-123', BigInt(-500));

      expect(mockPrismaUser.update).toHaveBeenCalledWith({
        where: { id: 'user-id-123' },
        data: {
          storageUsedBytes: {
            increment: BigInt(-500),
          },
        },
      });
    });
  });

  describe('checkUserStorageQuota', () => {
    it('should return quota info when user has sufficient space', async () => {
      const mockUser = createMockUser({
        storageQuotaBytes: BigInt(1073741824), // 1GB
        storageUsedBytes: BigInt(500000000), // 500MB
      });
      mockPrismaUser.findUnique.mockResolvedValue(mockUser);

      const result = await checkUserStorageQuota('user-id-123', BigInt(100000000)); // 100MB

      expect(result.hasQuota).toBe(true);
      expect(result.quotaBytes).toBe(BigInt(1073741824));
      expect(result.usedBytes).toBe(BigInt(500000000));
      expect(result.remainingBytes).toBe(BigInt(573741824)); // 1GB - 500MB
    });

    it('should return hasQuota false when file exceeds remaining space', async () => {
      const mockUser = createMockUser({
        storageQuotaBytes: BigInt(1073741824), // 1GB
        storageUsedBytes: BigInt(1000000000), // ~950MB
      });
      mockPrismaUser.findUnique.mockResolvedValue(mockUser);

      const result = await checkUserStorageQuota('user-id-123', BigInt(100000000)); // 100MB

      expect(result.hasQuota).toBe(false);
      expect(result.remainingBytes).toBe(BigInt(73741824)); // Only ~70MB remaining
    });

    it('should throw error when user not found', async () => {
      mockPrismaUser.findUnique.mockResolvedValue(null);

      await expect(checkUserStorageQuota('non-existent', BigInt(1000))).rejects.toThrow(
        'User not found'
      );
    });

    it('should return hasQuota true when file exactly matches remaining space', async () => {
      const mockUser = createMockUser({
        storageQuotaBytes: BigInt(1000),
        storageUsedBytes: BigInt(500),
      });
      mockPrismaUser.findUnique.mockResolvedValue(mockUser);

      const result = await checkUserStorageQuota('user-id-123', BigInt(500)); // Exactly 500 remaining

      expect(result.hasQuota).toBe(true);
    });
  });

  describe('getUserDefaultTimerDays', () => {
    it('should return user default timer days', async () => {
      const mockUser = createMockUser({ defaultTimerDays: 14 });
      mockPrismaUser.findUnique.mockResolvedValue(mockUser);

      const result = await getUserDefaultTimerDays('user-id-123');

      expect(mockPrismaUser.findUnique).toHaveBeenCalledWith({
        where: { id: 'user-id-123' },
        select: { defaultTimerDays: true },
      });
      expect(result).toBe(14);
    });

    it('should return null for non-existent user', async () => {
      mockPrismaUser.findUnique.mockResolvedValue(null);

      const result = await getUserDefaultTimerDays('non-existent');

      expect(result).toBeNull();
    });

    it('should return default 7 days for user with default settings', async () => {
      const mockUser = createMockUser(); // defaultTimerDays: 7
      mockPrismaUser.findUnique.mockResolvedValue(mockUser);

      const result = await getUserDefaultTimerDays('user-id-123');

      expect(result).toBe(7);
    });
  });

  describe('Public Token Generation (Task 19)', () => {
    it('should create video with unique public token', async () => {
      const mockVideo = createMockVideo({
        publicToken: '550e8400-e29b-41d4-a716-446655440000',
      });
      mockPrismaVideo.create.mockResolvedValue(mockVideo);

      const videoData: CreateVideoData = {
        userId: 'user-id-123',
        title: 'Test Video',
        filePath: 'user-id-123/test.mp4',
        fileSizeBytes: BigInt(1000),
        mimeType: 'video/mp4',
        distributeAt: new Date(),
      };

      const result = await createVideo(videoData);

      // Verify publicToken is a valid UUID format
      expect(result.publicToken).toMatch(
        /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
      );
    });

    it('should return video with publicToken in response', async () => {
      const mockVideo = createMockVideo();
      mockPrismaVideo.create.mockResolvedValue(mockVideo);

      const videoData: CreateVideoData = {
        userId: 'user-id-123',
        title: 'Test Video',
        filePath: 'user-id-123/test.mp4',
        fileSizeBytes: BigInt(1000),
        mimeType: 'video/mp4',
        distributeAt: new Date(),
      };

      const result = await createVideo(videoData);

      // publicToken should be defined and not empty
      expect(result.publicToken).toBeDefined();
      expect(result.publicToken.length).toBeGreaterThan(0);
    });

    it('should be able to find video by publicToken after creation', async () => {
      const publicToken = '12345678-1234-1234-1234-123456789abc';
      const mockVideo = createMockVideo({ publicToken });
      mockPrismaVideo.findUnique.mockResolvedValue(mockVideo);

      const result = await findVideoByPublicToken(publicToken);

      expect(result).toBeDefined();
      expect(result?.publicToken).toBe(publicToken);
    });
  });
});
